/*
 * Rosetta
 *
 * A standard for blockchain interaction
 *
 * API version: 1.2.3
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package api

import (
	"context"
	"math/big"

	"github.com/celo-org/rosetta/celo"
	"github.com/celo-org/rosetta/celo/client"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
)

// BlockApiService is a service that implents the logic for the BlockApiServicer
// This service should implement the business logic for every endpoint for the BlockApi API.
// Include any external packages or services that will be required by this service.
type BlockApiService struct {
	celoClient *client.CeloClient
}

// NewBlockApiService creates a default api service
func NewBlockApiService(celoClient *client.CeloClient) BlockApiServicer {
	return &BlockApiService{
		celoClient: celoClient,
	}
}

func (b *BlockApiService) BlockHeader(ctx context.Context, blockIdentifier PartialBlockIdentifier) (*ethclient.ExtendedHeader, error) {
	var err error
	var blockHeader *ethclient.ExtendedHeader

	if blockIdentifier.Hash != nil {
		hash := common.HexToHash(*blockIdentifier.Hash)
		blockHeader, err = b.celoClient.Eth.ExtendedHeaderByHash(ctx, hash)
		if err != nil {
			return nil, ErrCantFetchBlockHeader(err)
		}

		// If both were specified check the result matches
		if blockIdentifier.Index != nil && blockHeader.Number.Cmp(big.NewInt(*blockIdentifier.Index)) != 0 {
			return nil, ErrCantFetchBlockHeader(ErrBadBlockIdentifier)
		}

	} else if blockIdentifier.Index != nil {
		blockHeader, err = b.celoClient.Eth.ExtendedHeaderByNumber(ctx, big.NewInt(*blockIdentifier.Index))
		if err != nil {
			return nil, ErrCantFetchBlockHeader(err)
		}
	} else {
		blockHeader, err = b.celoClient.Eth.ExtendedHeaderByNumber(ctx, nil)
		if err != nil {
			return nil, ErrCantFetchBlockHeader(err)
		}
	}

	return blockHeader, nil

}

// Block - Get a Block
func (b *BlockApiService) Block(ctx context.Context, request BlockRequest) (interface{}, error) {

	err := ValidateNetworkId(&request.NetworkIdentifier)
	if err != nil {
		return nil, err
	}

	blockHeader, err := b.BlockHeader(ctx, request.BlockIdentifier)
	if err != nil {
		return nil, err
	}

	return &BlockResponse{
		Block: Block{
			BlockIdentifier:       *HeaderToBlockIdentifier(&blockHeader.Header),
			ParentBlockIdentifier: *HeaderToParentBlockIdentifier(&blockHeader.Header),
			Timestamp:             int64(blockHeader.Time), // TODO unsafe casting from uint to int 64
			Transactions:          MapTxHashesToTransaction(blockHeader.Transactions),
		},
	}, nil

}

// BlockTransaction - Get a Block Transaction
func (s *BlockApiService) BlockTransaction(ctx context.Context, request BlockTransactionRequest) (interface{}, error) {

	err := ValidateNetworkId(&request.NetworkIdentifier)
	if err != nil {
		return nil, err
	}

	blockHeader, err := s.BlockHeader(ctx, FullToPartialBlockIdentifier(request.BlockIdentifier))
	if err != nil {
		return nil, err
	}

	txHash := common.HexToHash(request.TransactionIdentifier.Hash)
	if !HeaderContainsTx(blockHeader, txHash) {
		return nil, ErrMissingTxInBlock
	}

	tx, _, err := s.celoClient.Eth.TransactionByHash(ctx, txHash)
	if err != nil {
		return nil, ErrRpcError("TransactionByHash", err)
	}

	receipt, err := s.celoClient.Eth.TransactionReceipt(ctx, tx.Hash())
	if err != nil {
		return nil, ErrRpcError("TransactionReceipt", err)
	}

	txTracer := celo.NewTxTracer(ctx, s.celoClient, &blockHeader.Header, tx, receipt)

	gasDetails, err := txTracer.GasDetail()
	if err != nil {
		return nil, err
	}

	operations := GasDetailsToOperations(gasDetails)

	transfers, err := txTracer.TransferDetail()
	opIndex := int64(len(operations))
	for i, transfer := range transfers {
		operations = append(operations, TransferToOperations(opIndex+int64(2*i), &transfer)...)
	}

	return &BlockTransactionResponse{
		Transaction: Transaction{
			TransactionIdentifier: TransactionIdentifier{Hash: tx.Hash().Hex()},
			Operations:            operations,
		},
	}, nil
}
