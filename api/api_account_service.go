/*
 * Rosetta
 *
 * A standard for blockchain interaction
 *
 * API version: 1.2.3
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package api

import (
	"context"
	"math/big"

	"github.com/celo-org/rosetta/celo"
	"github.com/celo-org/rosetta/celo/client"
	"github.com/celo-org/rosetta/celo/wrapper"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
)

// AccountApiService is a service that implents the logic for the AccountApiServicer
// This service should implement the business logic for every endpoint for the AccountApi API.
// Include any external packages or services that will be required by this service.
type AccountApiService struct {
	celoClient  *client.CeloClient
	chainParams *celo.ChainParameters
}

// NewAccountApiService creates a default api service
func NewAccountApiService(celoClient *client.CeloClient, chainParams *celo.ChainParameters) AccountApiServicer {
	return &AccountApiService{
		celoClient:  celoClient,
		chainParams: chainParams,
	}
}

type VotesByGroup = map[common.Address]*big.Int
type ElectionVotes = struct {
	active  VotesByGroup
	pending VotesByGroup
}

func (s *AccountApiService) GetAccountElectionVotes(account common.Address, opts *bind.CallOpts) (*ElectionVotes, error) {
	registryWrapper, err := wrapper.NewRegistry(s.celoClient)
	if err != nil {
		return nil, err
	}

	election, err := registryWrapper.GetElection(opts, s.celoClient.Eth)
	if err != nil {
		return nil, err
	}

	groups, err := election.GetGroupsVotedForByAccount(opts, account)
	if err != nil {
		return nil, err
	}

	var votes *ElectionVotes
	for _, groupAddr := range groups {
		pendingAmt, err := election.GetPendingVotesForGroupByAccount(opts, groupAddr, account)
		if err != nil {
			return nil, err
		}
		votes.pending[groupAddr] = pendingAmt

		activeAmt, err := election.GetActiveVotesForGroupByAccount(opts, groupAddr, account)
		if err != nil {
			return nil, err
		}
		votes.active[groupAddr] = activeAmt
	}

	return votes, nil
}

func (s *AccountApiService) GetAccountLockedGold(account common.Address, opts *bind.CallOpts) (*big.Int, error) {
	registryWrapper, err := wrapper.NewRegistry(s.celoClient)
	if err != nil {
		return nil, err
	}

	lockedGold, err := registryWrapper.GetLockedGold(opts, s.celoClient.Eth)
	if err != nil {
		return nil, err
	}

	lockedGoldNonVotingAmt, err := lockedGold.GetAccountNonvotingLockedGold(opts, account)
	if err != nil {
		return nil, err
	}

	return lockedGoldNonVotingAmt, nil
}

// AccountBalance - Get an Account Balance
func (s *AccountApiService) AccountBalance(ctx context.Context, accountBalanceRequest AccountBalanceRequest) (interface{}, error) {

	err := ValidateNetworkId(&accountBalanceRequest.NetworkIdentifier, s.chainParams)
	if err != nil {
		return nil, err
	}

	accountAddr := common.HexToAddress(accountBalanceRequest.AccountIdentifier.Address)

	latestHeader, err := s.celoClient.Eth.HeaderByNumber(ctx, nil) // nil == latest
	if err != nil {
		return nil, err
	}
	latestBlockOpts := &bind.CallOpts{
		BlockNumber: latestHeader.Number,
		Context:     ctx,
	}

	// fetch amounts
	goldAmt, err := s.celoClient.Eth.BalanceAt(ctx, accountAddr, latestHeader.Number)
	if err != nil {
		return nil, err
	}

	lockedGoldAmt, err := s.GetAccountLockedGold(accountAddr, latestBlockOpts)
	if err != nil {
		return nil, err
	}

	electionVotes, err := s.GetAccountElectionVotes(accountAddr, latestBlockOpts)
	if err != nil {
		return nil, err
	}

	// construct balances
	balances := make([]Balance, 0, 2+len(electionVotes.active)+len(electionVotes.pending))

	goldBalance := NewCeloGoldBalance(accountAddr, goldAmt, nil)
	lockedGoldBalance := NewCeloGoldBalance(accountAddr, lockedGoldAmt, NewSubAccountIdentifier("LockedGoldNonVoting", "", ""))

	balances = append(balances, *goldBalance, *lockedGoldBalance)

	for groupAddr, activeAmt := range electionVotes.active {
		activeGroupSubAccount := NewSubAccountIdentifier("ElectionActiveVotes", "group", groupAddr.String())
		activeVotesForGroupBalance := NewCeloGoldBalance(accountAddr, activeAmt, activeGroupSubAccount)
		balances = append(balances, *activeVotesForGroupBalance)
	}

	for groupAddr, pendingAmt := range electionVotes.pending {
		pendingGroupSubAccount := NewSubAccountIdentifier("ElectionPendingVotes", "group", groupAddr.String())
		pendingVotesForGroupbalance := NewCeloGoldBalance(accountAddr, pendingAmt, pendingGroupSubAccount)
		balances = append(balances, *pendingVotesForGroupbalance)
	}

	// return balance response
	response := AccountBalanceResponse{
		BlockIdentifier: *HeaderToBlockIdentifier(latestHeader),
		Balances:        balances,
	}
	return response, nil
}
