/*
 * Rosetta
 *
 * A standard for blockchain interaction
 *
 * API version: 1.2.3
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package api

import (
	"context"
	"math/big"

	"github.com/celo-org/rosetta/analyzer"
	"github.com/celo-org/rosetta/celo"
	"github.com/celo-org/rosetta/celo/client"
	"github.com/celo-org/rosetta/celo/wrapper"
	"github.com/celo-org/rosetta/internal/utils"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
)

// AccountApiService is a service that implents the logic for the AccountApiServicer
// This service should implement the business logic for every endpoint for the AccountApi API.
// Include any external packages or services that will be required by this service.
type AccountApiService struct {
	celoClient  *client.CeloClient
	chainParams *celo.ChainParameters
}

// NewAccountApiService creates a default api service
func NewAccountApiService(celoClient *client.CeloClient, chainParams *celo.ChainParameters) AccountApiServicer {
	return &AccountApiService{
		celoClient:  celoClient,
		chainParams: chainParams,
	}
}

// AccountBalance - Get an Account Balance
func (s *AccountApiService) AccountBalance(ctx context.Context, accountBalanceRequest AccountBalanceRequest) (interface{}, error) {

	err := ValidateNetworkId(&accountBalanceRequest.NetworkIdentifier, s.chainParams)
	if err != nil {
		return nil, err
	}

	accountAddr := common.HexToAddress(accountBalanceRequest.AccountIdentifier.Address)

	latestHeader, err := s.celoClient.Eth.HeaderByNumber(ctx, nil) // nil == latest
	if err != nil {
		return nil, err
	}
	latestBlockOpts := &bind.CallOpts{
		BlockNumber: latestHeader.Number,
		Context:     ctx,
	}

	// available rosetta balances at latest block
	var balances []Balance

	goldAmt, err := s.celoClient.Eth.BalanceAt(ctx, accountAddr, latestHeader.Number)
	if err != nil {
		return nil, err
	}

	goldBalance := NewCeloGoldBalance(analyzer.NewAccount(accountAddr, analyzer.AccMain), goldAmt)
	balances = append(balances, *goldBalance)

	registryWrapper, err := wrapper.NewRegistry(s.celoClient)
	if err == client.ErrContractNotDeployed {
		// Nothing is deployed => ignore lockedGold & election balances
		return &AccountBalanceResponse{
			BlockIdentifier: *HeaderToBlockIdentifier(latestHeader),
			Balances:        balances,
		}, nil
	} else if err != nil {
		return nil, err
	}

	// Fetch LockedGold Balances
	lockedGoldWrapper, err := wrapper.NewLockedGold(s.celoClient, registryWrapper)
	if err == nil {
		nonVotingLockedGold, err := lockedGoldWrapper.GetAccountNonvotingLockedGold(latestBlockOpts, accountAddr)
		if err != nil {
			return nil, err
		}

		lockedGoldBalance := NewCeloGoldBalance(analyzer.NewAccount(accountAddr, analyzer.AccLockedGoldNonVoting), nonVotingLockedGold)
		balances = append(balances, *lockedGoldBalance)

		totalPending, err := lockedGoldWrapper.GetTotalPendingWithdrawals(latestBlockOpts, accountAddr)
		if err != nil {
			return nil, err
		}
		balances = append(balances, *NewCeloGoldBalance(analyzer.NewAccount(accountAddr, analyzer.AccLockedGoldNonVoting), totalPending))

	} else if err != client.ErrContractNotDeployed {
		return nil, err
	}

	// Fetch Election (Votes) Balances
	electionWrapper, err := wrapper.NewElection(s.celoClient, registryWrapper)
	if err == nil {
		electionVotes, err := electionWrapper.GetAccountElectionVotes(latestBlockOpts, accountAddr)
		if err != nil {
			return nil, err
		}

		// On RC0 we can't track pending vs active votes, so we sum them up as "pending"
		// TODO(rc1) fix
		// correct code
		// for groupAddr, activeAmt := range electionVotes.Active {
		// 	account := analyzer.NewVotingAccount(accountAddr, analyzer.AccLockedGoldVotingActive, groupAddr)
		// 	balances = append(balances, *NewCeloGoldBalance(account, activeAmt))
		// }

		// for groupAddr, pendingAmt := range electionVotes.Pending {
		// 	account := analyzer.NewVotingAccount(accountAddr, analyzer.AccLockedGoldVotingPending, groupAddr)
		// 	balances = append(balances, *NewCeloGoldBalance(account, pendingAmt))
		// }

		// add active (as pending)
		for groupAddr, activeAmt := range electionVotes.Active {
			pendingAmt, ok := electionVotes.Pending[groupAddr]
			if ok {
				delete(electionVotes.Pending, groupAddr)
			} else {
				pendingAmt = utils.Big0
			}
			total := new(big.Int).Add(pendingAmt, activeAmt)

			account := analyzer.NewVotingAccount(accountAddr, analyzer.AccLockedGoldVotingPending, groupAddr)
			balances = append(balances, *NewCeloGoldBalance(account, total))
		}

		// add remaining pending
		for groupAddr, pendingAmt := range electionVotes.Pending {
			account := analyzer.NewVotingAccount(accountAddr, analyzer.AccLockedGoldVotingPending, groupAddr)
			balances = append(balances, *NewCeloGoldBalance(account, pendingAmt))
		}

	} else if err != client.ErrContractNotDeployed {
		return nil, err
	}

	// return balance response
	response := AccountBalanceResponse{
		BlockIdentifier: *HeaderToBlockIdentifier(latestHeader),
		Balances:        balances,
	}
	return response, nil
}
